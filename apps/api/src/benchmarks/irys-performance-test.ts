/**
 * Irys Performance Benchmark Test
 *
 * Ïã§Ï†ú Irys ÏøºÎ¶¨ ÏÑ±Îä•ÏùÑ Ï∏°Ï†ïÌïòÏó¨ Irys-Only ÏïÑÌÇ§ÌÖçÏ≤òÏùò Ïã§ÌòÑ Í∞ÄÎä•ÏÑ±ÏùÑ ÌèâÍ∞ÄÌï©ÎãàÎã§.
 *
 * ÌÖåÏä§Ìä∏ ÏãúÎÇòÎ¶¨Ïò§:
 * 1. Îã®Ïùº Ìä∏ÎûúÏû≠ÏÖò Ï°∞Ìöå
 * 2. ÌÉúÍ∑∏ Í∏∞Î∞ò Í≤ÄÏÉâ (10Í∞ú Í≤∞Í≥º)
 * 3. ÌÉúÍ∑∏ Í∏∞Î∞ò Í≤ÄÏÉâ (100Í∞ú Í≤∞Í≥º)
 * 4. Î≥µÏû°Ìïú ÌÉúÍ∑∏ Ï°∞Ìï© Í≤ÄÏÉâ
 * 5. Îç∞Ïù¥ÌÑ∞ fetch Ìè¨Ìï® Ï†ÑÏ≤¥ ÏõåÌÅ¨ÌîåÎ°úÏö∞
 * 6. N+1 ÏøºÎ¶¨ ÏãúÎÇòÎ¶¨Ïò§ (Í¥ÄÍ≥ÑÌòï Îç∞Ïù¥ÌÑ∞)
 */

import Query from '@irys/query';

interface BenchmarkResult {
  test: string;
  avgTime: number;
  minTime: number;
  maxTime: number;
  iterations: number;
  status: 'success' | 'error';
  error?: string;
}

class IrysPerformanceBenchmark {
  private query: Query;
  private results: BenchmarkResult[] = [];

  constructor() {
    this.query = new Query();
  }

  /**
   * ÏãúÍ∞Ñ Ï∏°Ï†ï Ïú†Ìã∏Î¶¨Ìã∞
   */
  private async measureTime(
    fn: () => Promise<any>,
    iterations: number = 5
  ): Promise<{ avg: number; min: number; max: number; times: number[] }> {
    const times: number[] = [];

    for (let i = 0; i < iterations; i++) {
      const start = performance.now();
      try {
        await fn();
      } catch (error) {
        console.error(`Iteration ${i + 1} failed:`, error);
      }
      const end = performance.now();
      times.push(end - start);

      // Í∞Å Ï∏°Ï†ï ÏÇ¨Ïù¥Ïóê 100ms ÎåÄÍ∏∞ (rate limiting Î∞©ÏßÄ)
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    return {
      avg: times.reduce((a, b) => a + b, 0) / times.length,
      min: Math.min(...times),
      max: Math.max(...times),
      times
    };
  }

  /**
   * Test 1: Îã®Ïùº Ìä∏ÎûúÏû≠ÏÖò Ï°∞Ìöå
   */
  async testSingleTransactionQuery() {
    console.log('\nüìä Test 1: Single Transaction Query');
    console.log('‚îÅ'.repeat(50));

    try {
      const { avg, min, max, times } = await this.measureTime(async () => {
        await this.query
          .search('irys:transactions')
          .limit(1);
      }, 10);

      console.log(`‚úÖ Average: ${avg.toFixed(2)}ms`);
      console.log(`   Min: ${min.toFixed(2)}ms, Max: ${max.toFixed(2)}ms`);
      console.log(`   All times: ${times.map(t => t.toFixed(0)).join(', ')}ms`);

      this.results.push({
        test: 'Single Transaction Query',
        avgTime: avg,
        minTime: min,
        maxTime: max,
        iterations: 10,
        status: 'success'
      });
    } catch (error) {
      console.error('‚ùå Error:', error);
      this.results.push({
        test: 'Single Transaction Query',
        avgTime: 0,
        minTime: 0,
        maxTime: 0,
        iterations: 10,
        status: 'error',
        error: String(error)
      });
    }
  }

  /**
   * Test 2: ÌÉúÍ∑∏ Í∏∞Î∞ò Í≤ÄÏÉâ (10Í∞ú Í≤∞Í≥º)
   */
  async testSmallTagSearch() {
    console.log('\nüìä Test 2: Tag-based Search (10 results)');
    console.log('‚îÅ'.repeat(50));

    try {
      const { avg, min, max, times } = await this.measureTime(async () => {
        await this.query
          .search('irys:transactions')
          .tags([
            { name: 'Content-Type', values: ['application/json'] }
          ])
          .limit(10);
      }, 10);

      console.log(`‚úÖ Average: ${avg.toFixed(2)}ms`);
      console.log(`   Min: ${min.toFixed(2)}ms, Max: ${max.toFixed(2)}ms`);
      console.log(`   All times: ${times.map(t => t.toFixed(0)).join(', ')}ms`);

      this.results.push({
        test: 'Small Tag Search (10 results)',
        avgTime: avg,
        minTime: min,
        maxTime: max,
        iterations: 10,
        status: 'success'
      });
    } catch (error) {
      console.error('‚ùå Error:', error);
      this.results.push({
        test: 'Small Tag Search (10 results)',
        avgTime: 0,
        minTime: 0,
        maxTime: 0,
        iterations: 10,
        status: 'error',
        error: String(error)
      });
    }
  }

  /**
   * Test 3: ÌÉúÍ∑∏ Í∏∞Î∞ò Í≤ÄÏÉâ (100Í∞ú Í≤∞Í≥º)
   */
  async testLargeTagSearch() {
    console.log('\nüìä Test 3: Tag-based Search (100 results)');
    console.log('‚îÅ'.repeat(50));

    try {
      const { avg, min, max, times } = await this.measureTime(async () => {
        await this.query
          .search('irys:transactions')
          .tags([
            { name: 'Content-Type', values: ['application/json'] }
          ])
          .limit(100);
      }, 5);

      console.log(`‚úÖ Average: ${avg.toFixed(2)}ms`);
      console.log(`   Min: ${min.toFixed(2)}ms, Max: ${max.toFixed(2)}ms`);
      console.log(`   All times: ${times.map(t => t.toFixed(0)).join(', ')}ms`);

      this.results.push({
        test: 'Large Tag Search (100 results)',
        avgTime: avg,
        minTime: min,
        maxTime: max,
        iterations: 5,
        status: 'success'
      });
    } catch (error) {
      console.error('‚ùå Error:', error);
      this.results.push({
        test: 'Large Tag Search (100 results)',
        avgTime: 0,
        minTime: 0,
        maxTime: 0,
        iterations: 5,
        status: 'error',
        error: String(error)
      });
    }
  }

  /**
   * Test 4: Î≥µÏû°Ìïú ÌÉúÍ∑∏ Ï°∞Ìï© Í≤ÄÏÉâ
   */
  async testComplexTagSearch() {
    console.log('\nüìä Test 4: Complex Multi-Tag Search');
    console.log('‚îÅ'.repeat(50));

    try {
      const { avg, min, max, times } = await this.measureTime(async () => {
        await this.query
          .search('irys:transactions')
          .tags([
            { name: 'App-Name', values: ['DeBHuB'] },
            { name: 'Entity-Type', values: ['document', 'project'] },
            { name: 'Content-Type', values: ['application/json'] }
          ])
          .limit(20);
      }, 10);

      console.log(`‚úÖ Average: ${avg.toFixed(2)}ms`);
      console.log(`   Min: ${min.toFixed(2)}ms, Max: ${max.toFixed(2)}ms`);
      console.log(`   All times: ${times.map(t => t.toFixed(0)).join(', ')}ms`);

      this.results.push({
        test: 'Complex Multi-Tag Search',
        avgTime: avg,
        minTime: min,
        maxTime: max,
        iterations: 10,
        status: 'success'
      });
    } catch (error) {
      console.error('‚ùå Error:', error);
      this.results.push({
        test: 'Complex Multi-Tag Search',
        avgTime: 0,
        minTime: 0,
        maxTime: 0,
        iterations: 10,
        status: 'error',
        error: String(error)
      });
    }
  }

  /**
   * Test 5: Ï†ÑÏ≤¥ ÏõåÌÅ¨ÌîåÎ°úÏö∞ (ÏøºÎ¶¨ + Îç∞Ïù¥ÌÑ∞ fetch)
   */
  async testFullWorkflow() {
    console.log('\nüìä Test 5: Full Workflow (Query + Data Fetch)');
    console.log('‚îÅ'.repeat(50));

    try {
      const { avg, min, max, times } = await this.measureTime(async () => {
        // 1. ÏøºÎ¶¨ Ïã§Ìñâ
        const results = await this.query
          .search('irys:transactions')
          .tags([
            { name: 'Content-Type', values: ['application/json'] }
          ])
          .limit(5);

        // 2. Í∞Å Í≤∞Í≥ºÏùò Îç∞Ïù¥ÌÑ∞ fetch
        if (results && results.length > 0) {
          await Promise.all(
            results.slice(0, 5).map(async (tx: any) => {
              const response = await fetch(`https://gateway.irys.xyz/${tx.id}`);
              if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
              }
              return await response.text();
            })
          );
        }
      }, 5);

      console.log(`‚úÖ Average: ${avg.toFixed(2)}ms`);
      console.log(`   Min: ${min.toFixed(2)}ms, Max: ${max.toFixed(2)}ms`);
      console.log(`   All times: ${times.map(t => t.toFixed(0)).join(', ')}ms`);

      this.results.push({
        test: 'Full Workflow (Query + 5 Fetches)',
        avgTime: avg,
        minTime: min,
        maxTime: max,
        iterations: 5,
        status: 'success'
      });
    } catch (error) {
      console.error('‚ùå Error:', error);
      this.results.push({
        test: 'Full Workflow (Query + 5 Fetches)',
        avgTime: 0,
        minTime: 0,
        maxTime: 0,
        iterations: 5,
        status: 'error',
        error: String(error)
      });
    }
  }

  /**
   * Test 6: N+1 ÏøºÎ¶¨ ÏãúÎÇòÎ¶¨Ïò§ (BaaSÏóêÏÑú ÌùîÌïú Ìå®ÌÑ¥)
   * Ïòà: ÌîÑÎ°úÏ†ùÌä∏ 10Í∞ú Ï°∞Ìöå ‚Üí Í∞Å ÌîÑÎ°úÏ†ùÌä∏Ïùò Î¨∏ÏÑú Í∞úÏàò Ï°∞Ìöå
   */
  async testNPlusOneQuery() {
    console.log('\nüìä Test 6: N+1 Query Pattern (Project + Document Counts)');
    console.log('‚îÅ'.repeat(50));

    try {
      const { avg, min, max, times } = await this.measureTime(async () => {
        // 1. ÌîÑÎ°úÏ†ùÌä∏ 10Í∞ú Ï°∞Ìöå
        const projects = await this.query
          .search('irys:transactions')
          .tags([
            { name: 'App-Name', values: ['DeBHuB'] },
            { name: 'Entity-Type', values: ['project'] }
          ])
          .limit(10);

        // 2. Í∞Å ÌîÑÎ°úÏ†ùÌä∏Ïùò Î¨∏ÏÑú Í∞úÏàò Ï°∞Ìöå (N+1 ÏøºÎ¶¨)
        if (projects && projects.length > 0) {
          await Promise.all(
            projects.map(async (project: any) => {
              const projectIdTag = project.tags?.find((t: any) => t.name === 'Entity-ID');
              if (projectIdTag) {
                await this.query
                  .search('irys:transactions')
                  .tags([
                    { name: 'App-Name', values: ['DeBHuB'] },
                    { name: 'Entity-Type', values: ['document'] },
                    { name: 'Project-ID', values: [projectIdTag.value] }
                  ])
                  .limit(100);
              }
            })
          );
        }
      }, 3);

      console.log(`‚úÖ Average: ${avg.toFixed(2)}ms`);
      console.log(`   Min: ${min.toFixed(2)}ms, Max: ${max.toFixed(2)}ms`);
      console.log(`   All times: ${times.map(t => t.toFixed(0)).join(', ')}ms`);

      this.results.push({
        test: 'N+1 Query Pattern (10 projects + documents)',
        avgTime: avg,
        minTime: min,
        maxTime: max,
        iterations: 3,
        status: 'success'
      });
    } catch (error) {
      console.error('‚ùå Error:', error);
      this.results.push({
        test: 'N+1 Query Pattern',
        avgTime: 0,
        minTime: 0,
        maxTime: 0,
        iterations: 3,
        status: 'error',
        error: String(error)
      });
    }
  }

  /**
   * Test 7: PostgreSQL ÎπÑÍµê (ÎèôÏùºÌïú ÏøºÎ¶¨)
   */
  async testPostgreSQLComparison() {
    console.log('\nüìä Test 7: PostgreSQL Comparison (for reference)');
    console.log('‚îÅ'.repeat(50));

    try {
      // Í∞ÑÎã®Ìïú PostgreSQL ÏøºÎ¶¨ ÏãúÎÆ¨Î†àÏù¥ÏÖò
      const { PrismaClient } = await import('@prisma/client');
      const prisma = new PrismaClient();

      const { avg, min, max, times } = await this.measureTime(async () => {
        await prisma.project.findMany({
          take: 10,
          include: {
            _count: {
              select: { documents: true }
            }
          }
        });
      }, 10);

      console.log(`‚úÖ PostgreSQL Average: ${avg.toFixed(2)}ms`);
      console.log(`   Min: ${min.toFixed(2)}ms, Max: ${max.toFixed(2)}ms`);
      console.log(`   All times: ${times.map(t => t.toFixed(0)).join(', ')}ms`);

      this.results.push({
        test: 'PostgreSQL (10 projects + counts)',
        avgTime: avg,
        minTime: min,
        maxTime: max,
        iterations: 10,
        status: 'success'
      });

      await prisma.$disconnect();
    } catch (error) {
      console.error('‚ùå Error:', error);
      this.results.push({
        test: 'PostgreSQL Comparison',
        avgTime: 0,
        minTime: 0,
        maxTime: 0,
        iterations: 10,
        status: 'error',
        error: String(error)
      });
    }
  }

  /**
   * Î™®Îì† ÌÖåÏä§Ìä∏ Ïã§Ìñâ
   */
  async runAll() {
    console.log('üöÄ Starting Irys Performance Benchmark Tests');
    console.log('‚ïê'.repeat(50));
    console.log('Purpose: Evaluate Irys-Only architecture feasibility');
    console.log('Date:', new Date().toISOString());
    console.log('‚ïê'.repeat(50));

    await this.testSingleTransactionQuery();
    await this.testSmallTagSearch();
    await this.testLargeTagSearch();
    await this.testComplexTagSearch();
    await this.testFullWorkflow();
    await this.testNPlusOneQuery();
    await this.testPostgreSQLComparison();

    this.printSummary();
    this.generateMarkdownReport();
  }

  /**
   * ÏöîÏïΩ Ï∂úÎ†•
   */
  private printSummary() {
    console.log('\n\nüìä BENCHMARK SUMMARY');
    console.log('‚ïê'.repeat(70));
    console.log('Test Name'.padEnd(40), 'Avg Time'.padEnd(15), 'Status');
    console.log('‚îÄ'.repeat(70));

    this.results.forEach(result => {
      const name = result.test.padEnd(40);
      const time = result.status === 'success'
        ? `${result.avgTime.toFixed(2)}ms`.padEnd(15)
        : 'ERROR'.padEnd(15);
      const status = result.status === 'success' ? '‚úÖ' : '‚ùå';

      console.log(name, time, status);
    });

    console.log('‚ïê'.repeat(70));

    // ÏÑ±Îä• Î∂ÑÏÑù
    const successResults = this.results.filter(r => r.status === 'success');
    if (successResults.length > 0) {
      console.log('\nüéØ Performance Analysis:');

      const irysResults = successResults.filter(r => !r.test.includes('PostgreSQL'));
      const pgResult = successResults.find(r => r.test.includes('PostgreSQL'));

      if (irysResults.length > 0) {
        const avgIrysTime = irysResults.reduce((sum, r) => sum + r.avgTime, 0) / irysResults.length;
        console.log(`   - Average Irys query time: ${avgIrysTime.toFixed(2)}ms`);
      }

      if (pgResult) {
        console.log(`   - PostgreSQL query time: ${pgResult.avgTime.toFixed(2)}ms`);

        if (irysResults.length > 0) {
          const avgIrysTime = irysResults.reduce((sum, r) => sum + r.avgTime, 0) / irysResults.length;
          const ratio = avgIrysTime / pgResult.avgTime;
          console.log(`   - Irys is ${ratio.toFixed(1)}x ${ratio > 1 ? 'slower' : 'faster'} than PostgreSQL`);
        }
      }

      // BaaS Ï†ÅÌï©ÏÑ± ÌèâÍ∞Ä
      console.log('\nüéì BaaS Suitability Assessment:');
      const avgIrysTime = irysResults.reduce((sum, r) => sum + r.avgTime, 0) / irysResults.length;

      if (avgIrysTime < 100) {
        console.log('   ‚úÖ EXCELLENT: Sub-100ms response time - BaaS ready!');
      } else if (avgIrysTime < 300) {
        console.log('   ‚úÖ GOOD: Sub-300ms response time - Acceptable for most BaaS use cases');
      } else if (avgIrysTime < 1000) {
        console.log('   ‚ö†Ô∏è  MARGINAL: Sub-1s response time - May work for some use cases');
      } else {
        console.log('   ‚ùå POOR: >1s response time - Not suitable for typical BaaS');
      }
    }
  }

  /**
   * Markdown Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±
   */
  private generateMarkdownReport() {
    const report = `# Irys Performance Benchmark Results

**Date:** ${new Date().toISOString()}
**Purpose:** Evaluate Irys-Only architecture feasibility for BaaS platform

---

## Test Results

| Test Name | Avg Time (ms) | Min (ms) | Max (ms) | Iterations | Status |
|-----------|---------------|----------|----------|------------|--------|
${this.results.map(r =>
  `| ${r.test} | ${r.avgTime.toFixed(2)} | ${r.minTime.toFixed(2)} | ${r.maxTime.toFixed(2)} | ${r.iterations} | ${r.status === 'success' ? '‚úÖ' : '‚ùå'} |`
).join('\n')}

---

## Performance Analysis

${this.generateAnalysis()}

---

## Conclusion

${this.generateConclusion()}

---

## Raw Data

\`\`\`json
${JSON.stringify(this.results, null, 2)}
\`\`\`
`;

    console.log('\n\nüìÑ Markdown report generated');
    console.log('   Save this to: docs/IRYS_BENCHMARK_RESULTS.md');
    console.log('\n' + '‚îÄ'.repeat(70) + '\n');
    console.log(report);
  }

  private generateAnalysis(): string {
    const successResults = this.results.filter(r => r.status === 'success');
    if (successResults.length === 0) return 'No successful tests to analyze.';

    const irysResults = successResults.filter(r => !r.test.includes('PostgreSQL'));
    const pgResult = successResults.find(r => r.test.includes('PostgreSQL'));

    let analysis = '';

    if (irysResults.length > 0) {
      const avgIrysTime = irysResults.reduce((sum, r) => sum + r.avgTime, 0) / irysResults.length;
      analysis += `### Irys Query Performance\n\n`;
      analysis += `- **Average query time:** ${avgIrysTime.toFixed(2)}ms\n`;
      analysis += `- **Fastest query:** ${Math.min(...irysResults.map(r => r.minTime)).toFixed(2)}ms\n`;
      analysis += `- **Slowest query:** ${Math.max(...irysResults.map(r => r.maxTime)).toFixed(2)}ms\n\n`;
    }

    if (pgResult) {
      analysis += `### PostgreSQL Comparison\n\n`;
      analysis += `- **PostgreSQL query time:** ${pgResult.avgTime.toFixed(2)}ms\n`;

      if (irysResults.length > 0) {
        const avgIrysTime = irysResults.reduce((sum, r) => sum + r.avgTime, 0) / irysResults.length;
        const ratio = avgIrysTime / pgResult.avgTime;
        analysis += `- **Speed ratio:** Irys is ${ratio.toFixed(1)}x ${ratio > 1 ? 'slower' : 'faster'} than PostgreSQL\n\n`;
      }
    }

    return analysis;
  }

  private generateConclusion(): string {
    const successResults = this.results.filter(r => r.status === 'success');
    if (successResults.length === 0) return 'Tests failed - unable to draw conclusions.';

    const irysResults = successResults.filter(r => !r.test.includes('PostgreSQL'));
    const avgIrysTime = irysResults.reduce((sum, r) => sum + r.avgTime, 0) / irysResults.length;

    if (avgIrysTime < 100) {
      return `**‚úÖ Irys-Only architecture is VIABLE for BaaS!**

With an average query time of ${avgIrysTime.toFixed(2)}ms, Irys provides sub-100ms responses that meet BaaS performance requirements. This suggests that a pure Irys-based architecture could work for real-time applications.

**Recommendation:** Consider Irys-Only architecture as a viable option, with caching strategies for optimal performance.`;
    } else if (avgIrysTime < 300) {
      return `**‚ö†Ô∏è Irys-Only architecture is MARGINALLY VIABLE for BaaS**

With an average query time of ${avgIrysTime.toFixed(2)}ms, Irys is in the acceptable range for many BaaS use cases, though not ideal for real-time collaboration.

**Recommendation:** Hybrid approach may still be beneficial for scenarios requiring sub-100ms responses, but Irys-Only could work with proper caching and UX considerations.`;
    } else {
      return `**‚ùå Irys-Only architecture is NOT VIABLE for typical BaaS**

With an average query time of ${avgIrysTime.toFixed(2)}ms, Irys does not meet the performance expectations for a typical BaaS platform where users expect sub-100ms responses.

**Recommendation:** Maintain hybrid architecture (PostgreSQL + Irys) for production BaaS platform. Use Irys for permanence and PostgreSQL for performance.`;
    }
  }
}

// Ïã§Ìñâ
if (require.main === module) {
  const benchmark = new IrysPerformanceBenchmark();
  benchmark.runAll().catch(console.error);
}

export default IrysPerformanceBenchmark;
